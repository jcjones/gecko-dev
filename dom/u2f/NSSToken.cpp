/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim:set ts=2 sw=2 sts=2 et cindent: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "NSSToken.h"
#include "nss.h"
#include "pk11pub.h"

#define U2F_PUBLIC_KEY_LEN 65
#define U2F_PARAM_LEN 32
#define U2F_SIGNED_DATA_LEN 2*U2F_PARAM_LEN + 1 + 4

#define P256_OID "\x06\x08\x2A\x86\x48\xCE\x3D\x03\x01\x07"
#define P256_OID_LEN 10

namespace mozilla {
namespace dom {

NSSToken::NSSToken()
  : mInitialized(false)
  , mCounter(0)
{}

NSSToken::~NSSToken()
{
  if (isAlreadyShutDown()) {
    return;
  }
  shutdown(calledFromObject);
}

nsresult
NSSToken::Init()
{
  if (mInitialized) {
    return NS_OK;
  }

  SECStatus srv = NSS_NoDB_Init(NULL);
  if (srv != SECSuccess) {
    return NS_ERROR_FAILURE;
  }

  mSlot = PK11_GetInternalSlot();
  if (!mSlot.get()) {
    return NS_ERROR_FAILURE;
  }

  mInitialized = true;
  return NS_OK;
}

const nsString NSSToken::mVersion = NS_LITERAL_STRING("U2F_V2");

const nsString&
NSSToken::Version() const
{
  return mVersion;
}

static SECItem*
keyHandleFromKeyPair(SECKEYPrivateKey* aPrivKey, SECKEYPublicKey *aPubKey)
{
  ScopedSECItem privKeyItem(::SECITEM_AllocItem(nullptr, nullptr, 0));
  SECStatus srv = PK11_ReadRawAttribute(PK11_TypePrivKey, aPrivKey,
                                        CKA_VALUE, privKeyItem);
  if (srv != SECSuccess) {
    return nullptr;
  }

  if (aPubKey->u.ec.publicValue.len != U2F_PUBLIC_KEY_LEN) {
    return nullptr;
  }

  size_t keyHandleLen = U2F_PUBLIC_KEY_LEN + privKeyItem->len;
  SECItem *keyHandleItem = ::SECITEM_AllocItem(nullptr, nullptr, keyHandleLen);
  memcpy(keyHandleItem->data,
         aPubKey->u.ec.publicValue.data, aPubKey->u.ec.publicValue.len);
  memcpy(keyHandleItem->data + U2F_PUBLIC_KEY_LEN,
         privKeyItem->data, privKeyItem->len);
  return keyHandleItem;
}

static SECKEYPrivateKey* privateKeyFromKeyHandle(PK11SlotInfo *aSlot,
                                                 const SECItem* aKeyHandle)
{
  SECItem param = {siBuffer, (unsigned char*) P256_OID, P256_OID_LEN};
  SECItem pubKeyItem  = {siBuffer, aKeyHandle->data, U2F_PUBLIC_KEY_LEN};
  SECItem privKeyItem = {siBuffer, aKeyHandle->data + U2F_PUBLIC_KEY_LEN,
                                   aKeyHandle->len - U2F_PUBLIC_KEY_LEN};


  ScopedSECItem objID(PK11_MakeIDFromPubKey(&pubKeyItem));
  if (!objID.get()) {
    return nullptr;
  }
  CK_OBJECT_CLASS privateKeyValue = CKO_PRIVATE_KEY;
  CK_BBOOL falseValue = CK_FALSE;
  CK_KEY_TYPE ecValue = CKK_EC;
  CK_ATTRIBUTE keyTemplate[9] = {
    { CKA_CLASS,            &privateKeyValue,     sizeof(privateKeyValue) },
    { CKA_KEY_TYPE,         &ecValue,             sizeof(ecValue) },
    { CKA_TOKEN,            &falseValue,          sizeof(falseValue) },
    { CKA_SENSITIVE,        &falseValue,          sizeof(falseValue) },
    { CKA_PRIVATE,          &falseValue,          sizeof(falseValue) },
    { CKA_ID,               objID->data,          objID->len },
    { CKA_EC_PARAMS,        param.data,           param.len },
    { CKA_EC_POINT,         pubKeyItem.data,      pubKeyItem.len },
    { CKA_VALUE,            privKeyItem.data,     privKeyItem.len },
  };
  ScopedPK11GenericObject obj(PK11_CreateGenericObject(aSlot, keyTemplate,
                                                       PR_ARRAY_SIZE(keyTemplate),
                                                       PR_FALSE));
  if (!obj) {
    return nullptr;
  }
  return PK11_FindKeyByKeyID(aSlot, objID, NULL);
}

/*
 * A U2F Register operation causes a new key pair to be generated by the token.
 * The token then returns the public key of the key pair, and a handle to the
 * private key.  The input parameters are used only for attestation, which this
 * token does not provide.  (We'll see how that works!)
 *
 * The format of the return registration data is as follows:
 *
 * Bytes  Value
 *   1    0x05
 *  65    public key
 *   1    key handle length
 *   *    key handle
 *   *    attestation certificate (omitted for now)
 *   *    attestation signature (omitted for now)
 *
 */
nsresult
NSSToken::Register(const CryptoBuffer& /* aChallengeParam */,
                   const CryptoBuffer& /* aApplicationParam */,
                   CryptoBuffer& aRegistrationData) const
{
  nsNSSShutDownPreventionLock locker;
  if (isAlreadyShutDown()) {
    return NS_ERROR_NOT_AVAILABLE;
  }

  if (!mInitialized) {
    return NS_ERROR_NOT_INITIALIZED;
  }

  ScopedSECKEYPrivateKey privKey;
  ScopedSECKEYPublicKey pubKey;

  // Generate a key pair
  CK_MECHANISM_TYPE mechanism = CKM_EC_KEY_PAIR_GEN;
  SECItem param = {siBuffer, (unsigned char*) P256_OID, P256_OID_LEN};
  SECKEYPublicKey* pubKeyRaw;
  privKey = PK11_GenerateKeyPair(mSlot, mechanism, &param, &pubKeyRaw,
                                 PR_FALSE, PR_FALSE, NULL);
  pubKey = pubKeyRaw;
  if (!privKey.get() || !pubKey.get()) {
    return NS_ERROR_FAILURE;
  }

  // Check that the public key has the correct length
  if (pubKey->u.ec.publicValue.len != U2F_PUBLIC_KEY_LEN) {
    return NS_ERROR_FAILURE;
  }

  // The key handle will be (pubKey || privateValue)
  ScopedSECItem keyHandleItem(keyHandleFromKeyPair(privKey, pubKey));
  if (!keyHandleItem.get()) {
    return NS_ERROR_FAILURE;
  }

  // Serialize the registration data
  if (!aRegistrationData.SetLength(1 + U2F_PUBLIC_KEY_LEN + 1 + keyHandleItem->len,
                                   fallible)) {
    return NS_ERROR_FAILURE;
  };
  uint8_t *data = aRegistrationData.Elements();
  data[0] = 0x05;
  memcpy(data + 1, pubKey->u.ec.publicValue.data, pubKey->u.ec.publicValue.len);
  data[1 + U2F_PUBLIC_KEY_LEN] = keyHandleItem->len;
  memcpy(data + 1 + U2F_PUBLIC_KEY_LEN + 1, keyHandleItem->data, keyHandleItem->len);
  return NS_OK;
}

/*
 * A U2F Sign operation creates a signature over the "param" arguments (plus
 * some other stuff) using the private key indicated in the key handle argument.
 *
 * The format of the signed data is as follows:
 *
 *  32    Application parameter
 *   1    User presence (0x01)
 *   4    Counter
 *  32    Challenge parameter
 *
 * The format of the signature data is as follows:
 *
 *   1    User presence
 *   4    Counter
 *   *    Signature
 *
 */
nsresult
NSSToken::Sign(const CryptoBuffer& aApplicationParam,
               const CryptoBuffer& aChallengeParam,
               const CryptoBuffer& aKeyHandle,
               CryptoBuffer& aSignatureData)
{
  nsNSSShutDownPreventionLock locker;
  if (isAlreadyShutDown()) {
    return NS_ERROR_NOT_AVAILABLE;
  }

  if (!mInitialized) {
    return NS_ERROR_NOT_INITIALIZED;
  }

  if ((aChallengeParam.Length() != U2F_PARAM_LEN) ||
      (aApplicationParam.Length() != U2F_PARAM_LEN)) {
    return NS_ERROR_ILLEGAL_VALUE;
  }

  // Decode the key handle
  ScopedSECItem keyHandleItem(::SECITEM_AllocItem(nullptr, nullptr, 0));
  if (!aKeyHandle.ToSECItem(nullptr, keyHandleItem)) {
    return NS_ERROR_FAILURE;
  }
  ScopedSECKEYPrivateKey privKey(privateKeyFromKeyHandle(mSlot, keyHandleItem));
  if (!privKey.get()) {
    return NS_ERROR_FAILURE;
  }

  // Increment the counter and turn it into a SECItem
  mCounter += 1;
  ScopedSECItem counterItem(::SECITEM_AllocItem(nullptr, nullptr, 4));
  counterItem->data[0] = (mCounter >> 24) & 0xFF;
  counterItem->data[1] = (mCounter >> 16) & 0xFF;
  counterItem->data[2] = (mCounter >>  8) & 0xFF;
  counterItem->data[3] = (mCounter >>  0) & 0xFF;

  // Compute the signature
  ScopedSECItem signedDataItem(::SECITEM_AllocItem(nullptr, nullptr,
                                                   U2F_SIGNED_DATA_LEN));
  memcpy(signedDataItem->data, aApplicationParam.Elements(), U2F_PARAM_LEN);
  signedDataItem->data[U2F_PARAM_LEN] = 0x01;
  memcpy(signedDataItem->data + U2F_PARAM_LEN + 1,
         counterItem->data, counterItem->len);
  memcpy(signedDataItem->data + U2F_PARAM_LEN + 1 + counterItem->len,
         aChallengeParam.Elements(), U2F_PARAM_LEN);

  ScopedSECItem signatureItem(::SECITEM_AllocItem(nullptr, nullptr, 0));
  SECStatus srv = SEC_SignData(signatureItem.get(), signedDataItem->data,
                               signedDataItem->len, privKey.get(),
                               SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE);
  if (srv != SECSuccess) {
    return NS_ERROR_FAILURE;
  }

  // Assmeble the signature data
  if (!aSignatureData.SetLength(1 + 4 + signatureItem->len, fallible)) {
    return NS_ERROR_FAILURE;
  };
  uint8_t *data = aSignatureData.Elements();
  data[0] = 0x01;
  memcpy(data + 1, counterItem->data, counterItem->len);
  memcpy(data + 1 + counterItem->len, signatureItem->data, signatureItem->len);
  return NS_OK;
}


} // namespace dom
} // namespace mozilla
